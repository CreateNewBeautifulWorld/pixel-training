# Uint8 é‡åŒ–ç¥ç»ç½‘ç»œ - ç«¯åˆ°ç«¯å®ç°

ä¸€ä¸ªé¢å‘ç¡¬ä»¶å®ç°çš„é‡åŒ–ç¥ç»ç½‘ç»œï¼Œä»PyTorchè®­ç»ƒåˆ°C++æ¨ç†å†åˆ°RTLè®¾è®¡ã€‚

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

- **ç½‘ç»œç»“æ„**: 48 â†’ 16 â†’ 3 (ä¸¤å±‚å…¨è¿æ¥)
- **è¾“å…¥**: 16ä¸ªåƒç´  Ã— 3é€šé“(RGB) = 48ä¸ªuint8å€¼
- **è¾“å‡º**: 3åˆ†ç±» (0/1/2)
- **é‡åŒ–**: å…¨uint8é‡åŒ–ï¼ˆæƒé‡ã€æ¿€æ´»ã€è¾“å…¥ï¼‰
- **ç›®æ ‡**: æœ€ç»ˆç”¨RTLå®ç°ï¼Œé€‚åˆASIC/FPGAéƒ¨ç½²

## ğŸ—‚ï¸ æ–‡ä»¶ç»“æ„

```
.
â”œâ”€â”€ train_uint8_nn.py      # PyTorchè®­ç»ƒè„šæœ¬
â”œâ”€â”€ inference_uint8.cpp    # C++æ¨ç†å¼•æ“
â”œâ”€â”€ uint8_nn_rtl.v         # Verilog RTLå‚è€ƒè®¾è®¡
â”œâ”€â”€ Makefile               # ç¼–è¯‘è„šæœ¬
â””â”€â”€ README.md              # æœ¬æ–‡æ¡£
```

## ğŸš€ å¿«é€Ÿå¼€å§‹

### 1. å‡†å¤‡æ•°æ®

åˆ›å»ºè®­ç»ƒæ•°æ®æ–‡ä»¶ `train_data.txt`ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š

```
# æ¯è¡Œ: pixel0_r,pixel0_g,pixel0_b,...,pixel15_b,label
128,64,32,255,128,0,64,128,255,...,64,128,255,0
64,128,255,32,64,128,255,0,128,...,255,0,128,1
...
```

- å‰48ä¸ªæ•°å­—ï¼š16ä¸ªåƒç´ çš„RGBå€¼ï¼ˆæ¯ä¸ªå€¼0-255ï¼‰
- æœ€å1ä¸ªæ•°å­—ï¼šæ ‡ç­¾ï¼ˆ0ã€1æˆ–2ï¼‰

æˆ–è€…ä½¿ç”¨è„šæœ¬ç”Ÿæˆç¤ºä¾‹æ•°æ®ï¼š

```python
python train_uint8_nn.py  # ä¼šè‡ªåŠ¨ç”Ÿæˆç¤ºä¾‹æ•°æ®
```

### 2. è®­ç»ƒæ¨¡å‹

```bash
python train_uint8_nn.py
```

è¾“å‡ºæ–‡ä»¶ï¼š
- `model_uint8.pth` - PyTorchæ¨¡å‹
- `weights_uint8.bin` - é‡åŒ–æƒé‡ï¼ˆäºŒè¿›åˆ¶ï¼‰
- `weights_uint8.bin.txt` - æƒé‡ï¼ˆæ–‡æœ¬ï¼Œæ–¹ä¾¿æŸ¥çœ‹ï¼‰

è®­ç»ƒå‚æ•°ï¼š
- Epochs: 200
- Batch size: 32
- Learning rate: 0.001
- é‡åŒ–: uint8 (8-bit)

### 3. C++æ¨ç†

ç¼–è¯‘ï¼š

```bash
make
```

è¿è¡Œï¼š

```bash
./inference_uint8
```

è¾“å‡ºç¤ºä¾‹ï¼š

```
=== Uint8 é‡åŒ–ç¥ç»ç½‘ç»œæ¨ç†å¼•æ“ ===
æƒé‡åŠ è½½æˆåŠŸ!
FC1: [16, 48]
FC2: [3, 16]

--- å•æ ·æœ¬æµ‹è¯• ---
é¢„æµ‹ç±»åˆ«: 1

--- æµ‹è¯•é›†è¯„ä¼° ---
æ€»æ ·æœ¬æ•°: 1000
æ­£ç¡®æ•°: 876
å‡†ç¡®ç‡: 87.6%
```

## ğŸ”§ æŠ€æœ¯ç»†èŠ‚

### ç½‘ç»œæ¶æ„

```
è¾“å…¥å±‚ (48 uint8)
    â†“
å…¨è¿æ¥å±‚1 (48â†’16) + ReLU + é‡åŒ–
    â†“
éšè—å±‚ (16 uint8)
    â†“
å…¨è¿æ¥å±‚2 (16â†’3)
    â†“
Argmax
    â†“
åˆ†ç±»ç»“æœ (0/1/2)
```

### é‡åŒ–ç­–ç•¥

1. **è¾“å…¥é‡åŒ–**: åƒç´ å€¼æœ¬èº«å°±æ˜¯uint8 (0-255)
2. **æƒé‡é‡åŒ–**: 
   - è®­ç»ƒæ—¶ä½¿ç”¨æµ®ç‚¹
   - å¯¼å‡ºæ—¶é‡åŒ–åˆ°uint8
   - ä¿å­˜é‡åŒ–å‚æ•° (min/max) ä»¥ä¾¿è¿˜åŸ
3. **æ¿€æ´»é‡åŒ–**:
   - è®­ç»ƒæ—¶æ¨¡æ‹Ÿé‡åŒ–ï¼ˆé‡åŒ–æ„ŸçŸ¥è®­ç»ƒï¼‰
   - æ¨ç†æ—¶ç›´æ¥ä½¿ç”¨uint8è¿ç®—

### è®¡ç®—æµç¨‹

ä»¥Layer 1ä¸ºä¾‹ï¼š

```cpp
// 1. çŸ©é˜µä¹˜æ³• (uint8 Ã— uint8 = uint32)
for (i = 0; i < 16; i++) {
    sum = 0;
    for (j = 0; j < 48; j++) {
        sum += input[j] * weight[i][j];  // 8bit Ã— 8bit
    }
    // sumæœ€å¤§å€¼: 255 Ã— 255 Ã— 48 = 3,111,600 (éœ€è¦22bit)
    
    // 2. ç¼©æ”¾ + åŠ bias
    result = (sum >> 8) + bias[i];  // é™¤ä»¥256è¿‘ä¼¼å½’ä¸€åŒ–
    
    // 3. ReLU
    if (result < 0) result = 0;
    if (result > 255) result = 255;
    
    hidden[i] = result;  // uint8
}
```

### RTLè®¾è®¡è€ƒè™‘

#### æ–¹æ¡ˆ1: ä¸²è¡ŒMACï¼ˆçœèµ„æºï¼‰

- **é¢ç§¯**: å°
- **å»¶è¿Ÿ**: 48å‘¨æœŸ/ç¥ç»å…ƒ Ã— 16ç¥ç»å…ƒ = 768å‘¨æœŸ
- **åŠŸè€—**: ä½
- **é€‚åˆ**: FPGAã€é¢ç§¯å—é™çš„ASIC

```verilog
// ä¸€ä¸ªMACå•å…ƒæ—¶åˆ†å¤ç”¨
// ä¾æ¬¡è®¡ç®—16ä¸ªç¥ç»å…ƒ
for (neuron = 0; neuron < 16; neuron++) {
    for (i = 0; i < 48; i++) {
        mac += input[i] * weight[neuron][i];
    }
}
```

#### æ–¹æ¡ˆ2: å¹¶è¡ŒMACï¼ˆçœæ—¶é—´ï¼‰

- **é¢ç§¯**: å¤§ (16ä¸ªMACå•å…ƒ)
- **å»¶è¿Ÿ**: 1å‘¨æœŸï¼ˆæµæ°´çº¿ï¼‰
- **åŠŸè€—**: é«˜
- **é€‚åˆ**: é«˜æ€§èƒ½ASIC

```verilog
// 16ä¸ªå¹¶è¡ŒMACå•å…ƒ
genvar i;
for (i = 0; i < 16; i++) {
    mac_unit mac[i] (
        .input(pixel_data),
        .weight(weights[i]),
        .output(hidden[i])
    );
}
```

### èµ„æºä¼°ç®—

#### Layer 1 (48â†’16)

**ä¸²è¡Œç‰ˆæœ¬**:
- 1ä¸ª 8Ã—8 ä¹˜æ³•å™¨
- 1ä¸ª 24-bit ç´¯åŠ å™¨
- 768 bytes ROM (æƒé‡)
- 16 bytes ROM (bias)

**å¹¶è¡Œç‰ˆæœ¬**:
- 16ä¸ª 8Ã—8 ä¹˜æ³•å™¨
- 16ä¸ª 24-bit ç´¯åŠ å™¨
- 768 bytes ROM (æƒé‡)
- 16 bytes ROM (bias)

#### Layer 2 (16â†’3)

- 3ä¸ª 8Ã—8 ä¹˜æ³•å™¨
- 3ä¸ª 16-bit ç´¯åŠ å™¨
- 48 bytes ROM
- 3 bytes ROM

#### æ€»èµ„æº (ä¸²è¡Œå®ç°)

- **ROM**: ~835 bytes
- **ä¹˜æ³•å™¨**: 1ä¸ª 8Ã—8
- **ç´¯åŠ å™¨**: 1ä¸ª 24-bit
- **å‘¨æœŸæ•°**: ~800 cycles

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### è½¯ä»¶ä¼˜åŒ–

1. **SIMDæŒ‡ä»¤**: ä½¿ç”¨AVX2å¯ä»¥å¹¶è¡Œå¤„ç†å¤šä¸ªuint8ä¹˜æ³•
2. **æ‰¹å¤„ç†**: ä¸€æ¬¡æ¨ç†å¤šä¸ªæ ·æœ¬
3. **æŸ¥æ‰¾è¡¨**: ReLUå¯ä»¥ç”¨256é¡¹æŸ¥æ‰¾è¡¨å®ç°

### ç¡¬ä»¶ä¼˜åŒ–

1. **æƒé‡å‹ç¼©**: ä½¿ç”¨ç¨€ç–è¡¨ç¤ºæˆ–Huffmanç¼–ç 
2. **æµæ°´çº¿**: MACæ“ä½œåˆ†çº§æµæ°´
3. **è¿‘ä¼¼è®¡ç®—**: ç”¨ç§»ä½ä»£æ›¿é™¤æ³•
4. **æ—¶é’Ÿé—¨æ§**: ç©ºé—²æ—¶å…³é—­MACå•å…ƒ

## ğŸ”¬ æ‰©å±•æ–¹å‘

### æé«˜ç²¾åº¦

1. **å¢åŠ ä½å®½**: uint8 â†’ uint11 â†’ uint16
2. **æ··åˆç²¾åº¦**: æƒé‡uint8ï¼Œæ¿€æ´»uint16
3. **æ›´æ·±ç½‘ç»œ**: 48â†’32â†’16â†’3

### ç¡¬ä»¶å‹å¥½æ”¹è¿›

1. **äºŒå€¼åŒ–ç½‘ç»œ**: æƒé‡åªç”¨0/1ï¼Œç”¨XNORä»£æ›¿ä¹˜æ³•
2. **å¯¹æ•°é‡åŒ–**: ä¹˜æ³•å˜æˆåŠ æ³•
3. **å—æµ®ç‚¹**: å…±äº«æŒ‡æ•°

### ç‰¹æ®Šä¼˜åŒ–

```python
# ç”¨ç§»ä½è¿‘ä¼¼ä¹˜æ³•
# ä¾‹å¦‚: x * 13 â‰ˆ x * 16 - x * 4 + x
# ç¡¬ä»¶åªéœ€åŠ æ³•å™¨å’Œç§»ä½å™¨
```

## ğŸ“ ä»PyTorchåˆ°RTLçš„å®Œæ•´æµç¨‹

```
1. PyTorchè®­ç»ƒ
   â””â”€> model_uint8.pth (æµ®ç‚¹æƒé‡)
       
2. é‡åŒ–å¯¼å‡º
   â””â”€> weights_uint8.bin (uint8æƒé‡)
       â””â”€> weights_uint8.bin.txt (æ–‡æœ¬æ ¼å¼)
       
3. C++éªŒè¯
   â””â”€> inference_uint8 (å¯æ‰§è¡Œæ–‡ä»¶)
       â””â”€> éªŒè¯é‡åŒ–ç²¾åº¦æŸå¤±
       
4. RTLå®ç°
   â””â”€> uint8_nn_rtl.v
       â””â”€> ä».txtæ–‡ä»¶åŠ è½½æƒé‡åˆ°ROM
       â””â”€> Verilogä»¿çœŸéªŒè¯
       â””â”€> FPGAç»¼åˆ
       â””â”€> ASICæµç‰‡
```

## ğŸ¯ å®é™…åº”ç”¨

è¿™ä¸ªæ¶æ„é€‚åˆï¼š
- **è¾¹ç¼˜AIèŠ¯ç‰‡**: ä½åŠŸè€—å›¾åƒåˆ†ç±»
- **ä¼ æ„Ÿå™¨èåˆ**: å¤šé€šé“ä¿¡å·å¤„ç†
- **å®æ—¶æ¨ç†**: é«˜å¸§ç‡è§†é¢‘åˆ†æ
- **åµŒå…¥å¼è§†è§‰**: ADASã€å®‰é˜²æ‘„åƒå¤´

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **é‡åŒ–æŸå¤±**: uint8ä¼šæœ‰~2-5%çš„ç²¾åº¦æŸå¤±ï¼Œéœ€è¦å……åˆ†è®­ç»ƒ
2. **æº¢å‡ºé£é™©**: MACç´¯åŠ å¯èƒ½æº¢å‡ºï¼Œéœ€è¦ç”¨32-bitç´¯åŠ å™¨
3. **ç¼©æ”¾å› å­**: é™¤ä»¥256æ˜¯ç¡¬ä»¶å‹å¥½çš„ï¼Œä½†ä¸ä¸€å®šæœ€ä¼˜
4. **BiasèŒƒå›´**: ç¡®ä¿biasåœ¨uint8èŒƒå›´å†…

## ğŸ› ï¸ è°ƒè¯•æŠ€å·§

### æ£€æŸ¥é‡åŒ–ç²¾åº¦

```python
# æ¯”è¾ƒé‡åŒ–å‰åçš„è¾“å‡º
model_fp32 = ...  # åŸå§‹æµ®ç‚¹æ¨¡å‹
model_uint8 = ... # é‡åŒ–æ¨¡å‹

for test_data in test_loader:
    out_fp32 = model_fp32(test_data)
    out_uint8 = model_uint8(test_data)
    diff = (out_fp32 - out_uint8).abs().mean()
    print(f"é‡åŒ–è¯¯å·®: {diff:.4f}")
```

### RTLä»¿çœŸå¯¹æ¯”

```verilog
// ç”¨C++æ¨ç†ç»“æœä½œä¸ºå‚è€ƒ
initial begin
    $readmemh("test_input.hex", test_vector);
    $readmemh("expected_output.hex", expected);
    
    #10 check_results();
end
```

## ğŸ“š å‚è€ƒèµ„æ–™

- [Quantization and Training of Neural Networks for Efficient Integer-Arithmetic-Only Inference](https://arxiv.org/abs/1712.05877)
- [FINN: A Framework for Fast, Scalable Binarized Neural Network Inference](https://arxiv.org/abs/1612.07119)
- [Eyeriss: An Energy-Efficient Reconfigurable Accelerator for Deep CNNs](https://ieeexplore.ieee.org/document/7551407)

## ğŸ¤ è´¡çŒ®

æ¬¢è¿æäº¤Issueå’ŒPull Requestï¼

## ğŸ“„ è®¸å¯

MIT License
